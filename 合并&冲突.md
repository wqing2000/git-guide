# 合并&冲突

- `git merge <分支名>` ，分支合并
	- 合并分支之前，要运行 `git pull`，获取远程的新数据
- `git merge --abort` 合并分支出现冲突时，取消合并，一切回到合并前的状态

git merge --abort的一种使用情况
该命令仅仅在合并后导致冲突时才使用。git merge --abort将会抛弃合并过程并且尝试重建合并前的状态。但是，当合并开始时如果存在未commit的文件，git merge --abort在某些情况下将无法重现合并前的状态。（特别是这些未commit的文件在合并的过程中将会被修改时）

警告：运行git-merge时含有大量的未commit文件很容易让你陷入困境，这将使你在冲突中难以回退。因此非常不鼓励在使用git-merge时存在未commit的文件，建议使用git-stash命令将这些未commit文件暂存起来，并在解决冲突以后使用git stash pop把这些未commit文件还原出来。

---

* `git merge [branch-name]` 合并一个分支到当前分支,会把被合并分支和你当前分支的commit合并在一起,形成一个新的 commit 提交

* `git rebase [branch-name]` 合并一个分支到当前分支,把你当前分支的commit放到被合并分支的最后面

* `git rebase -i HEAD~[num]` 将最近num个commit合并成一个(这样推送到远程仓库后只有一个commit，避免污染远端的commit)

* `git pull --rebase` 相当于 git fetch + git rebase

* `git checkout <branch-name> [--] <file-name>` 从不同分支拉取当个文件

* `git checkout --theirs [file-name]` 表示检出另外分支, 即保存另外分支的改动,丢弃当前分支的改动。冲突时直接使用他人的代码

* `git checkout --ours [file-name]` 检出当前分支,即保存当前分支的改动,丢弃另外分支的改动。冲突时直接使用自己的代码

* `git cherry-pick <commit-id1> <commit-id2> ... `将指定的一些commit合并到当前分支

* `git cherry-pick <branch-name>` 将所选分支的最近一次提交，转移到当前分支

* 一次合并操作

  ```bash
  git checkout dev
  git rebase master
  #or git merge master
  #or git cherry-pick 8797a4f
  #出现冲突,修改文件后执行
  git add .
  #继续修改合并
  git rebase --continue
  #or git merge  --continue
  #or git cherry-pick  --continue
  #如果不想合并,直接终止
  git rebase --abort
  #or git merge --abort
  #or git cherry-pick  --abort
  ```

* git merge与git rebase 使用建议

  ```bash
  公共分支使用merge,个人分支使用rebase
  本地和远端对应同一条分支,优先使用rebase,而不是merge
  ```